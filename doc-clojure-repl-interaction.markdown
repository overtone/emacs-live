---

title:  Clojure REPL
filename: clojure-repl-interaction
layout: doc

---

So, you have [connected Emacs Live to a Clojure process](doc-clojure-connection.html) and are now sitting in front of a fresh `*nrepl*` buffer. Wonderful. Let us begin...

# Basic REPL interaction

The `*nrepl*` buffer is essentially equivalent to the `REPL-y` REPL that Leiningen delivers by default when you run `lein repl`, only you have all the usual advantages that Emacs Live provides you in addition to the power of [paredit](doc-clojure-paredit).

You should see the following at the top of your `*nrepl*` buffer:

    user>

It's doing two things. Firstly, it's telling you that your current namespace (i.e. `*ns*`) is `user` and secondly, it's waiting for you to give it a standard Clojure form to evaluate in the context of that namespace. For example you could type:

    user> (+ 1 2)

and then hit *RET*. and you should see the following

    user> (+ 1 2)
    3
    user>

It prints out the result of evaluating the form, and then gives you another `user>` prompt and patiently waits for your next move.

# REPL history

If you wish to access previous REPL lines you have two options. Firstly you can use the functions `nrepl-previous-input` (*M-p*) and `nrepl-next-input` (*M-n*) to cycle through the history. Once you have found the line you're looking for, you can then simply press *RET* to evaluate it again, or you have the option of editing it before evaluation.

Another option is to treat the `*nrepl*` buffer like a normal Emacs buffer and simply use the search commands `isearch-backward` (*C-r*) and `isearch-forward` (*C-s*) to search back and forth through the buffer. When the point is on the line you'd like to re-use, simply press *RET* and the form will be placed at the prompt ready for a subsequent *RET* to evaluate it or for it to be edited.

Of course, you're also free to use standard killing and yanking to manipulate the text.

# REPL Output

Output generated by evaluating forms on the `*nrepl*` REPL typically gets printed inline back in the `*nrepl*` buffer itself.

For example, if you evaluate the following by hitting *RET*:

    user> (println "foo")

You'll see the following output:

    user> (println "foo")
    foo
    nil
    user>

Note that the output from the `println` - `foo` is interleaved with the REPL output - `nil`.
